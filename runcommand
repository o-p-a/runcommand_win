#! /usr/bin/ruby -E:UTF-8
# -*- mode:Ruby; tab-width:4; coding:UTF-8; -*-
# vi:set ft=ruby ts=4 fenc=UTF-8 :
#----------------------------------------------------------------
# runcommand
#
# 2020/09/18 opa
#----------------------------------------------------------------

ProgName = "runcommand"
Version = "0.09"
#=====dpk===== Copyright2020
Copyright = "Copyright (c) 2020-2022 by opa"
#=====dpk=====

require 'pathname'
require 'tempfile'
require 'logger'

RETROPIE_CONFIG = File.expand_path("~/RetroPie-Config")
CONFIG_DIR = File.join(RETROPIE_CONFIG, "configs")
RETROARCH_EXE_NAME = "retroarch.exe"

#=====dpk===== os_is_windows?
# Windowsç’°å¢ƒä¸‹ã‹ã©ã†ã‹åˆ¤å®šã™ã‚‹
module Kernel
 module_function
	if RUBY_PLATFORM =~ /mswin(?!ce)|mingw|cygwin|bccwin|emx/i
		def os_is_windows?; true; end
	else
		def os_is_windows?; false; end
	end
end
#=====dpk=====

def relpath(path, from_dir)
	return Pathname(path).relative_path_from(Pathname(from_dir)).to_s
end

def treat_path_separator(path)
	path = path.gsub(File::ALT_SEPARATOR, File::SEPARATOR)  if File::ALT_SEPARATOR
	return path
end

# Win32(WIDE)ã¨ã®æ©‹æ¸¡ã—ç”¨
module Win32
	WIDE = Encoding::UTF_16LE
	WIDE_NUL = "\0".encode(WIDE).freeze
	WIDE_SIZE = WIDE_NUL.bytesize
	def self.wstr(size); WIDE_NUL * size; end
	def self.to_wstr!(s); s ? s.encode!(WIDE).concat(WIDE_NUL) : nil; end
	def self.to_wstr(s); s ? s.encode(WIDE).concat(WIDE_NUL) : nil; end
	def self.from_wstr(s)
		if s.respond_to?(:encode)
			s = s.dup.force_encoding(WIDE)  if s.encoding != WIDE
			return (i = s.index(WIDE_NUL)) ? s[0,i].encode! : s.encode
		else
			s = DL::CPtr.new(s)  if s.is_a?(Integer)
			return nil  if s.null?
			i = 0; i += 2  until s[i] == 0 && s[i+1] == 0
			return s.to_s(i).force_encoding(WIDE).encode!
		end
	end
end

# Ruby 2.0ä»¥é™ã¯Fiddleã‚’ä½¿ã†ã€Win32APIã®ã‚ˆã†ãªã‚‚ã®
if os_is_windows?
	if RUBY_VERSION >= "2"
		require 'fiddle/import'
		class Win32::API
			DLL = {}
			if Fiddle::SIZEOF_VOIDP == Fiddle::SIZEOF_LONG_LONG
				POINTER_TYPE = 'q*'
				CALLTYPEMAP = {cdecl: Fiddle::Function::DEFAULT, stdcall: Fiddle::Function::DEFAULT}
			else
				POINTER_TYPE = 'l!*'
				CALLTYPEMAP = {cdecl: Fiddle::Function::DEFAULT, stdcall: Fiddle::Function::STDCALL}
			end

			def typemap(t)
				case t
				 when /[PH]/i;	Fiddle::TYPE_VOIDP
				 when /[NLI]/i;	Fiddle::TYPE_LONG
				 when /[Q]/i;	Fiddle::TYPE_LONG_LONG
				 else			Fiddle::TYPE_VOID
				end
			end
			private :typemap

			def initialize(dllname, func, import, export = nil, calltype = :stdcall)
				@proto = [import].join.each_char.map { |v| typemap(v) }
				handle = DLL[dllname] ||= Fiddle.dlopen(dllname)
				@func = Fiddle::Function.new(handle[func], @proto, typemap(export),
						Fiddle::Importer.const_get(:CALL_TYPE_TO_ABI)[calltype])
			 rescue Fiddle::DLError => e
				raise LoadError, e.message, e.backtrace
			end

			def call(*args)
				args.each_with_index do |x, i|
					case @proto[i]
					 when Fiddle::TYPE_VOIDP
						if x.nil? || x.is_a?(String)
							args[i], = [x].pack("p").unpack(POINTER_TYPE)
						else
							args[i], = [x].pack("Q").unpack("q")
						end
					 when Fiddle::TYPE_LONG
						args[i], = [x].pack("I").unpack("i")
					 when Fiddle::TYPE_LONG_LONG
						args[i], = [x].pack("Q").unpack("q")
					end
				end
				ret, = @func.call(*args)
				return ret || 0
			end
		end
	else
		require 'win32api'
		class Win32::API < Win32API; end
	end
else
	class Win32::API; end
end

class Win32::API
	# def self.GetCommandLine
	# 	@@GetCommandLineW ||= new("kernel32", "GetCommandLineW", nil, "p")
	# 	Win32::from_wstr(@@GetCommandLineW.call)
	# end

	# def self.GetLastError
	# 	@@GetLastError ||= new("kernel32", "GetLastError", "", "i")
	# 	return @@GetLastError.call
	# end

	# WAIT_TIMEOUT = 0x102
	# def self.WaitForSingleObject(handle, milliseconds = -1)
	# 	@@WaitForSingleObject ||= new("kernel32", "WaitForSingleObject", "hi", "i")
	# 	return @@WaitForSingleObject.call(handle, milliseconds)
	# end

	def self.CreateProcess(cmdline)
		@@CreateProcess ||= new("kernel32", "CreateProcessW", "ppppiipppp", "i")
		# STARTUPINFO
	 	si = [0, nil, nil ,nil, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, nil, 0, 0, 0]
		si[0] = si.pack("Lp3L8S2PL3").bytesize
		si = si.pack("Lp3L8S2PL3")
		# PROCESS_INFORMATION
		pi = [0, 0, 0, 0].pack("QQLL")
		r = @@CreateProcess.call(nil, Win32::to_wstr(cmdline), nil, nil, 0, 0, nil, nil, si, pi)
		fail  if r == 0
		pi = pi.unpack("QQLL")
		return { hProcess:pi[0], hThread:pi[1], dwProcessId:pi[2], dwThreadId:pi[3] }
	end

	def self.CloseHandle(object)
		@@CloseHandle ||= new("kernel32", "CloseHandle", "h", "i")
		r = @@CloseHandle.call(object)
		fail  if r == 0
	end

	TH32CS_SNAPPROCESS = 0x2
	INVALID_HANDLE_VALUE = -1
	def self.CreateToolhelp32Snapshot(flags, pid = 0)
		@@CreateToolhelp32Snapshot ||= new("kernel32", "CreateToolhelp32Snapshot", "ii", "h")
		return @@CreateToolhelp32Snapshot.call(flags, pid)
	end

	MAX_PATH = 260
	def self.Process32Next(handle)
		@@Process32Next ||= new("kernel32", "Process32NextW", "hp", "i")
		# PROCESSENTRY32
		pe = [0, 0, 0, 0, nil, 0, 0, 0, 0, 0, Win32::wstr(MAX_PATH+2)]
		pe[0] = pe.pack("LLLLP4LLLLLa*").bytesize
		pe = pe.pack("LLLLP4LLLLLa*")
		r = @@Process32Next.call(handle, pe)
		if r != 0
			pe = pe.unpack("LLLLP4LLLLLa*")
			return {
				usage: pe[1],
				pid: pe[2],
				hid: pe[4],
				mid: pe[5],
				threads: pe[6],
				ppid: pe[7],
				priclassbase: pe[8],
				flags: pe[9],
				exefile: Win32::from_wstr(pe[10]),
			}
		else
			return nil
		end
	end
end

# å­å­«ãŒæ­»ã«çµ¶ãˆã‚‹ã¾ã§å¾…ã¤system()
def system_wait_descendant(cmdline)
	pi = Win32::API::CreateProcess(cmdline)
	Win32::API::CloseHandle(pi[:hThread])

	descendants = {}
	descendants[pi[:dwProcessId]] = { pid:pi[:dwProcessId], live:true }

	while !descendants.empty?
		descendants.each { |pid, desc| desc[:live] = nil }

		snapshot = Win32::API::CreateToolhelp32Snapshot(Win32::API::TH32CS_SNAPPROCESS)
		while (pe = Win32::API::Process32Next(snapshot))
			sn_pid = pe[:pid]
			sn_ppid = pe[:ppid]

			if descendants.has_key?(sn_pid)
				descendants[sn_pid][:live] = true
			end

			if descendants.has_key?(sn_ppid)
				descendants[sn_pid] = { pid:sn_pid, live:true }
			end
		end
		Win32::API::CloseHandle(snapshot)

		descendants.delete_if { |pid, desc| !desc[:live] }

		sleep(0.555)
	end

	Win32::API::CloseHandle(pi[:hProcess])
end

def exec_command_wait(*cmd)
	cmd = cmd.map{ |t| t =~ /\s/ ? "\"#{t}\"" : t }.join(" ")
	$log.info { "Exec: #{cmd}" }
	system_wait_descendant(cmd)
end

def get_retroarch_home
	if ENV["APPDATA"]
		dir = File.absolute_path("RetroArch", ENV["APPDATA"])
		if File.directory?(dir) && File.executable?(File.join(dir, RETROARCH_EXE_NAME))
			return dir
		end
	end

	if ENV["ChocolateyToolsLocation"]
		dir = File.absolute_path("RetroArch-Win64", ENV["ChocolateyToolsLocation"])
		if File.directory?(dir) && File.executable?(File.join(dir, RETROARCH_EXE_NAME))
			return dir
		end
	end

	if ENV["ProgramFiles(x86)"]
		dir = File.absolute_path("Steam/steamapps/common/RetroArch", ENV["ProgramFiles(x86)"])
		if File.directory?(dir) && File.executable?(File.join(dir, RETROARCH_EXE_NAME))
			return dir
		end
	end

	fail "RetroArch not found"
end

def retroarch_home
	return $retroarch_home ||= treat_path_separator(get_retroarch_home)
end

def retroarch_exename
	return $retroarch_exename ||= File.join(retroarch_home, RETROARCH_EXE_NAME)
end

def all_config_dir
	return $all_config_dir ||= treat_path_separator(File.join(CONFIG_DIR, "all"))
end

def set_system_name(system_name)
	$system_name ||= system_name
end

def system_name
	return $system_name
end

def system_config_dir
	return $system_config_dir ||= treat_path_separator(File.join(CONFIG_DIR, system_name))
end

def system_config_filename
	return $system_config_filename ||= File.join(system_config_dir, "retroarch.cfg")
end

def create_system_config_file
	savedir = File.join(system_config_dir, "saves")
	Dir.mkdir(savedir)  if !File.exist?(savedir)

	statedir = File.join(system_config_dir, "states")
	Dir.mkdir(statedir)  if !File.exist?(statedir)

	File.open(system_config_filename, "wb:UTF-8") do |ofile|
		ofile.puts("# Auto generated by runcommand.exe ðŸ™‚")
		ofile.puts("")

		ofile.puts(%[input_remapping_directory = "~/RetroPie-Config/configs/#{system_name}"])
		ofile.puts(%[rgui_config_directory = "~/RetroPie-Config/configs/#{system_name}"])
		ofile.puts(%[savefile_directory = "~/RetroPie-Config/configs/#{system_name}/saves"])
		ofile.puts(%[savestate_directory = "~/RetroPie-Config/configs/#{system_name}/states"])

		ofile.puts("")
		if ["msx", "pc98", "x68000"].include?(system_name)
			cname = File.join(all_config_dir, "retroarch_kbd.cfg")
			ofile.puts(%[#include "#{relpath(cname, system_config_dir)}"])
		else
			cname = File.join(all_config_dir, "retroarch.cfg")
			ofile.puts(%[#include "#{relpath(cname, system_config_dir)}"])
		end
	end
end

def run_retroarch(emulator_name, rom_filename)
	core_map = {
		"lr-beetle-pce-fast" =>	"mednafen_pce_fast",
		"lr-mupen64plus" =>		"mupen64plus_next",
		"lr-np2kai-ex" =>		"np2kai",
	}

	if core_map[emulator_name]
		core_name = core_map[emulator_name]
	else
		core_name = emulator_name.gsub(/^lr-/, "")	# å…ˆé ­ã® lr- ã‚’å–ã‚‹
		core_name = core_name.gsub("-", "_")		# - ã‚’ _ ã«ç½®ãæ›ãˆã‚‹
	end
	core_name += "_libretro.dll"
	$log.info { "Core: #{core_name}" }

	create_system_config_file

	cmd = [retroarch_exename]
	cmd += ["--libretro", File.join(retroarch_home, "cores", core_name)]
	cmd += ["--config", system_config_filename]
	if File.exist?(File.join(File.dirname($PROGRAM_NAME), "retrolog"))
		tmpconf = Tempfile.new(["retroarch_log", ".cfg"])
		tmpconf.puts('frontend_log_level = "0"');
		tmpconf.puts('libretro_log_level = "0"');
		tmpconf.puts('log_to_file = "true"');
		tmpconf.puts('log_to_file_timestamp = "true"');
		tmpconf.puts('log_verbosity = "true"');
		tmpconf.flush

		cmd += ["--verbose"]
		cmd += ["--appendconfig", tmpconf.path]
	end
	cmd += [rom_filename]

	exec_command_wait(*cmd)
end

def run_retroarch_plain
	cmd = [retroarch_exename]
	cmd += ["--config", system_config_filename]
	exec_command_wait(*cmd)
end

def determine_emulator_or_core(rom_filename)
	rom_basename = File.basename(rom_filename, ".*")

	filename = File.join(all_config_dir, "emulators.cfg")
	if File.readable?(filename)
		File.open(filename, "rt:UTF-8") do |file|
			file.each_line do |aline|
				aline.chomp!
				if aline =~ /^\s*([^\s_]+)_([^\s]+)\s*=\s*([^\s]+)\s*$/
					e_system, e_rom, e_emulator = $1, $2, $3
					e_emulator = $1  if e_emulator =~ /^"(.*)"$/

					if e_system == system_name && e_rom == rom_basename
						return e_emulator
					end
				end
			end
		end
	end

	filename = File.join(system_config_dir, "emulators.cfg")
	if File.readable?(filename)
		File.open(filename, "rt:UTF-8") do |file|
			file.each_line do |aline|
				aline.chomp!
				if aline =~ /^\s*default\s*=\s*([^\s]+)\s*$/
					e_emulator = $1
					e_emulator = $1  if e_emulator =~ /^"(.*)"$/
					return e_emulator
				end
			end
		end
	end

	return "(#{system_name})"
end

def main(args)
	$log = Logger.new($PROGRAM_NAME + ".log")
	$log.info { "--------" }
	$log.info { "Start: #{$PROGRAM_NAME} #{args.join(" ")}" }

	case args.size
	when 1
		emulator_name = args[0]
		case emulator_name
		when "retroarch"
			$log.info { "Emulator: RetroArch" }
			set_system_name("all")
			run_retroarch_plain
		else
			fail "Unknown emulator: #{emulator_name}"
		end
	when 4
		# video_mode = args[0]
		# $log.info { "video_mode: #{video_mode}" }
		# sys_port = args[1]
		# $log.info { "sys_port: #{sys_port}" }
		set_system_name(args[2])
		$log.info { "System: #{system_name}" }
		rom_filename = treat_path_separator(args[3])
		$log.info { "Rom: #{rom_filename}" }

		emulator_or_core = determine_emulator_or_core(rom_filename)
		case emulator_or_core
		when /^lr-/
			$log.info { "Emulator: RetroArch" }
			run_retroarch(emulator_or_core, rom_filename)
		when "drastic"
			$log.info { "Emulator: DraStic => RetroArch" }
			run_retroarch("lr-desmume", rom_filename)
		else
			fail "Unknown emulator: #{emulator_or_core}"
		end
	else
		fail "Wrong number of arguments (expected 1 or 4)"
	end

	$log.info { "End" }

	return 0
rescue Exception => e
	e.backtrace.each_with_index do |t, i|
		s = (i == 0) ? "#{t}: #{e.message} (#{e.class.name})" : "    from #{t}"
		$log.error(s)
		puts(s)
	end
	return 1
end

exit main(ARGV)
